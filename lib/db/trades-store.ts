/**
 * Trades Store - CRUD operations for trade data
 */

import { Trade } from "../models/trade";
import {
  combineAllLegGroups,
  CombinedTrade,
} from "../utils/combine-leg-groups";
import {
  INDEXES,
  promisifyRequest,
  STORES,
  withReadTransaction,
  withWriteTransaction,
} from "./index";
import {
  deleteCombinedTradesCache,
  getCombinedTradesCache,
  storeCombinedTradesCache,
} from "./combined-trades-cache";
import { deletePerformanceSnapshotCache } from "./performance-snapshot-cache";

// Track in-flight combined cache writes to avoid redundant work when multiple callers miss the cache simultaneously.
const combinedCacheInflight = new Map<string, Promise<void>>();

/**
 * Extended trade with block association
 */
export interface StoredTrade extends Trade {
  blockId: string;
  id?: number; // Auto-generated by IndexedDB
}

/**
 * Add trades for a block (batch operation)
 */
export async function addTrades(
  blockId: string,
  trades: Trade[]
): Promise<void> {
  if (trades.length === 0) return;

  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);

    // Use Promise.all for better performance with large datasets
    const promises = trades.map((trade) => {
      const storedTrade: StoredTrade = { ...trade, blockId };
      return promisifyRequest(store.add(storedTrade));
    });

    await Promise.all(promises);
  });

  // Invalidate caches since trades changed
  await deleteCombinedTradesCache(blockId);
  await deletePerformanceSnapshotCache(blockId);
}

/**
 * Get all trades for a block
 */
export async function getTradesByBlock(
  blockId: string
): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);
    const index = store.index(INDEXES.TRADES_BY_BLOCK);
    const result = await promisifyRequest(index.getAll(blockId));

    // Sort by date opened (chronological order)
    return result.sort((a, b) => {
      const dateA = new Date(a.dateOpened).getTime();
      const dateB = new Date(b.dateOpened).getTime();
      if (dateA !== dateB) return dateA - dateB;

      // If same date, sort by time
      return a.timeOpened.localeCompare(b.timeOpened);
    });
  });
}

/**
 * Get all trades for a block with optional leg group combining
 *
 * Uses cached combined trades when available for better performance.
 * Falls back to on-demand calculation if cache is missing.
 *
 * @param blockId - Block ID to fetch trades for
 * @param options.combineLegGroups - Whether to combine trades with same entry timestamp
 * @param options.skipCache - Force recalculation (bypass cache)
 * @returns Array of trades (combined or raw)
 */
export async function getTradesByBlockWithOptions(
  blockId: string,
  options: { combineLegGroups?: boolean; skipCache?: boolean } = {}
): Promise<(StoredTrade | (CombinedTrade & { blockId: string }))[]> {
  // If combining is enabled, check cache FIRST before fetching raw trades
  // This avoids the expensive raw trade fetch when we have cached data
  if (options.combineLegGroups && !options.skipCache) {
    const cachedTrades = await getCombinedTradesCache(blockId);
    if (cachedTrades) {
      // Add blockId back to cached trades
      return cachedTrades.map((trade) => ({ ...trade, blockId }));
    }
  }

  // Fetch raw trades (only if not combining, or cache miss)
  const trades = await getTradesByBlock(blockId);

  if (!options.combineLegGroups) {
    return trades;
  }

  // Cache miss: calculate combined trades on-demand
  const tradesWithoutBlockId = trades.map((storedTrade) => {
    const { blockId: _ignored, ...trade } = storedTrade;
    void _ignored;
    return trade as Trade;
  });
  const combined = combineAllLegGroups(tradesWithoutBlockId);

  queueCombinedTradesCache(blockId, combined);

  // Add blockId back to combined trades
  return combined.map((trade) => ({ ...trade, blockId }));
}

function queueCombinedTradesCache(blockId: string, combinedTrades: CombinedTrade[]) {
  if (combinedCacheInflight.has(blockId)) {
    return;
  }

  const task = storeCombinedTradesCache(blockId, combinedTrades)
    .catch((err) => {
      console.warn("Failed to cache combined trades:", err);
    })
    .finally(() => {
      combinedCacheInflight.delete(blockId);
    });

  combinedCacheInflight.set(blockId, task);
}

/**
 * Get trades by date range for a block
 */
export async function getTradesByDateRange(
  blockId: string,
  startDate: Date,
  endDate: Date
): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);
    const index = store.index("composite_block_date");

    // Create compound key range [blockId, startDate] to [blockId, endDate]
    const range = IDBKeyRange.bound(
      [blockId, startDate],
      [blockId, endDate],
      false,
      false
    );

    const result = await promisifyRequest(index.getAll(range));
    return result;
  });
}

/**
 * Get trades by strategy for a block
 */
export async function getTradesByStrategy(
  blockId: string,
  strategy: string
): Promise<StoredTrade[]> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);
    const blockIndex = store.index(INDEXES.TRADES_BY_BLOCK);
    const blockTrades = await promisifyRequest(blockIndex.getAll(blockId));

    // Filter by strategy (IndexedDB doesn't support compound queries easily)
    return blockTrades.filter((trade) => trade.strategy === strategy);
  });
}

/**
 * Get unique strategies for a block
 */
export async function getStrategiesByBlock(blockId: string): Promise<string[]> {
  const trades = await getTradesByBlock(blockId);
  const strategies = new Set(trades.map((trade) => trade.strategy));
  return Array.from(strategies).sort();
}

/**
 * Get trade count by block
 */
export async function getTradeCountByBlock(blockId: string): Promise<number> {
  return withReadTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);
    const index = store.index(INDEXES.TRADES_BY_BLOCK);
    const result = await promisifyRequest(index.count(blockId));
    return result;
  });
}

/**
 * Delete all trades for a block
 */
export async function deleteTradesByBlock(blockId: string): Promise<void> {
  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    const store = transaction.objectStore(STORES.TRADES);
    const index = store.index(INDEXES.TRADES_BY_BLOCK);
    const request = index.openCursor(IDBKeyRange.only(blockId));

    await new Promise<void>((resolve, reject) => {
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        } else {
          resolve();
        }
      };
      request.onerror = () => reject(request.error);
    });
  });

  // Invalidate caches since trades changed
  await deleteCombinedTradesCache(blockId);
  await deletePerformanceSnapshotCache(blockId);
}

/**
 * Update trades for a block (replace all)
 */
export async function updateTradesForBlock(
  blockId: string,
  trades: Trade[]
): Promise<void> {
  await withWriteTransaction(STORES.TRADES, async (transaction) => {
    // First delete existing trades
    const store = transaction.objectStore(STORES.TRADES);
    const index = store.index(INDEXES.TRADES_BY_BLOCK);
    const deleteRequest = index.openCursor(IDBKeyRange.only(blockId));

    await new Promise<void>((resolve, reject) => {
      deleteRequest.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        } else {
          resolve();
        }
      };
      deleteRequest.onerror = () => reject(deleteRequest.error);
    });

    // Then add new trades
    const promises = trades.map((trade) => {
      const storedTrade: StoredTrade = { ...trade, blockId };
      return promisifyRequest(store.add(storedTrade));
    });

    await Promise.all(promises);
  });

  // Invalidate caches since trades changed
  await deleteCombinedTradesCache(blockId);
  await deletePerformanceSnapshotCache(blockId);
}

/**
 * Get trade statistics for a block (aggregated)
 */
export async function getTradeStatistics(blockId: string): Promise<{
  totalTrades: number;
  totalPl: number;
  winningTrades: number;
  losingTrades: number;
  totalCommissions: number;
  dateRange: { start: Date | null; end: Date | null };
  strategies: string[];
}> {
  const trades = await getTradesByBlock(blockId);

  if (trades.length === 0) {
    return {
      totalTrades: 0,
      totalPl: 0,
      winningTrades: 0,
      losingTrades: 0,
      totalCommissions: 0,
      dateRange: { start: null, end: null },
      strategies: [],
    };
  }

  const totalTrades = trades.length;
  const totalPl = trades.reduce((sum, trade) => sum + trade.pl, 0);
  const winningTrades = trades.filter((trade) => trade.pl > 0).length;
  const losingTrades = trades.filter((trade) => trade.pl < 0).length;
  const totalCommissions = trades.reduce(
    (sum, trade) =>
      sum + trade.openingCommissionsFees + trade.closingCommissionsFees,
    0
  );

  // Get date range
  const dates = trades.map((trade) => new Date(trade.dateOpened));
  const start = new Date(Math.min(...dates.map((d) => d.getTime())));
  const end = new Date(Math.max(...dates.map((d) => d.getTime())));

  // Get unique strategies
  const strategies = Array.from(
    new Set(trades.map((trade) => trade.strategy))
  ).sort();

  return {
    totalTrades,
    totalPl,
    winningTrades,
    losingTrades,
    totalCommissions,
    dateRange: { start, end },
    strategies,
  };
}

/**
 * Search trades by text (strategy, legs, reason for close)
 */
export async function searchTrades(
  blockId: string,
  query: string
): Promise<StoredTrade[]> {
  const trades = await getTradesByBlock(blockId);
  const lowerQuery = query.toLowerCase();

  return trades.filter(
    (trade) =>
      trade.strategy.toLowerCase().includes(lowerQuery) ||
      trade.legs.toLowerCase().includes(lowerQuery) ||
      (trade.reasonForClose &&
        trade.reasonForClose.toLowerCase().includes(lowerQuery))
  );
}

/**
 * Get trades with pagination
 */
export async function getTradesPage(
  blockId: string,
  offset: number,
  limit: number
): Promise<{ trades: StoredTrade[]; total: number }> {
  const allTrades = await getTradesByBlock(blockId);
  const total = allTrades.length;
  const trades = allTrades.slice(offset, offset + limit);

  return { trades, total };
}

/**
 * Export trades to CSV format (for backup/analysis)
 */
export async function exportTradesToCSV(blockId: string): Promise<string> {
  const trades = await getTradesByBlock(blockId);

  if (trades.length === 0) {
    return "";
  }

  // CSV headers
  const headers = [
    "Date Opened",
    "Time Opened",
    "Opening Price",
    "Legs",
    "Premium",
    "Closing Price",
    "Date Closed",
    "Time Closed",
    "Avg. Closing Cost",
    "Reason For Close",
    "P/L",
    "No. of Contracts",
    "Funds at Close",
    "Margin Req.",
    "Strategy",
    "Opening Commissions + Fees",
    "Closing Commissions + Fees",
    "Opening Short/Long Ratio",
    "Closing Short/Long Ratio",
    "Opening VIX",
    "Closing VIX",
    "Gap",
    "Movement",
    "Max Profit",
    "Max Loss",
  ];

  // Convert trades to CSV rows
  const rows = trades.map((trade) => {
    // Format dateOpened - handle both Date objects and strings
    const dateOpened =
      trade.dateOpened instanceof Date
        ? trade.dateOpened.toISOString().split("T")[0]
        : typeof trade.dateOpened === "string"
        ? new Date(trade.dateOpened).toISOString().split("T")[0]
        : trade.dateOpened;

    return [
      dateOpened,
      trade.timeOpened,
      trade.openingPrice.toString(),
      trade.legs,
      trade.premium.toString(),
      trade.closingPrice?.toString() || "",
      trade.dateClosed instanceof Date
        ? trade.dateClosed.toISOString().split("T")[0]
        : typeof trade.dateClosed === "string" && trade.dateClosed !== ""
        ? new Date(trade.dateClosed).toISOString().split("T")[0]
        : "",
      trade.timeClosed || "",
      trade.avgClosingCost?.toString() || "",
      trade.reasonForClose || "",
      trade.pl.toString(),
      trade.numContracts.toString(),
      trade.fundsAtClose.toString(),
      trade.marginReq.toString(),
      trade.strategy,
      trade.openingCommissionsFees.toString(),
      trade.closingCommissionsFees.toString(),
      trade.openingShortLongRatio.toString(),
      trade.closingShortLongRatio?.toString() || "",
      trade.openingVix?.toString() || "",
      trade.closingVix?.toString() || "",
      trade.gap?.toString() || "",
      trade.movement?.toString() || "",
      trade.maxProfit?.toString() || "",
      trade.maxLoss?.toString() || "",
    ];
  });

  // Combine headers and rows
  const csvContent = [headers, ...rows]
    .map((row) => row.map((field) => `"${field}"`).join(","))
    .join("\n");

  return csvContent;
}
